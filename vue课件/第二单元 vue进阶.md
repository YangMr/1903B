# vue进阶

[toc]

 

## 一、vue计算属性

### 1.1 什么是计算属性

​	**模板内的表达式常用于简单的运算，当其过长或逻辑复杂时，会难以维护，本章的计算属性 就是用于解决该问题的。** 

​	**我们己经可以搭建出一个简单的 Vue 应用，在模板中双向绑定一些数据 或表达式了。但是表达式如果过长，或逻辑更为复杂时，就会变得雕肿甚至难以阅读和维护，比如:** 

```vue
<div>
	{{ text.split (’,’).reverse().join (’,’)}} 
</div>
```

​	**这里的表达式包含 3 个操作，并不是很清晰，所以在遇到复杂的逻辑时应该使用计算属性。 上例可以用计算属性进行改写:** 

```vue
<div id=”app”>
	{{ reversedText }}
</div> 
<script>
var app =new Vue({ 
  el :’#app’,
	data :{
		text : ’123,456’
  },
  computed:{
    reversedText: function () {
  		//这里的 this 指向的是当前的 Vue 实例
  		return this.text.split(’,’).reverse() .join(’,’);
		}       
  }
})
</script>                             
```

​	**所有的计算属性都以函数的形式写在 Vue 实例内的 computed选项内，最终返回计算后的结果。** 

### 1.2 计算属性用法

​	**在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回 一个结 果就可以。除了上例简单的用法，计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据 变化，计算属性就会重新执行，视图也会更新。例如，下面的示例展示的是在购物车内两个包裹的 物品总价:** 

​	**当 packagel 或 package2 中的商品有任何变化，比如购买数量变化或增删商品时，计算属性 prices就会自动更新， 视图中的总价也会自动变化。** 

​	**每一个计算属性都包含-个 ge忧er和一个 setter，我们上面的两个示例都是计算属性的默认用 法， 只是利用了 ge忧er来读取。在你需要时，也可以提供一个 se忧er 函数， 当手动修改计算属性的 值就像修改一个普通数据那样时，就会触发 se忧er函数，执行一些自定义的操作，例如:** 

​	**当执行 app.fullName=’John Doe';时， se忧er就会被调用，数据 firstName和 lastName 都会相对 更新，视图同样也会更新。** 

​	**绝大多数情况下，我们只会用默认的 getter方法来读取一个计算属性，在业务中很少用到阴阳r, 所以在声明 一个计算属性时，可以直接使用默认的写法，不必将 getter和 setter都声明。** 

​	**计算属性除了上述简单的文本插值外，还经常用于动态地设置元素的样式名称 class 和内联样 式 style，在下章会介绍这方面的内容。当使用组件时，计算属性也经常用来动态传递 props，这也 会在第 7 章组件里详细介绍。** 

​	**计算属性还有两个很实用的小技巧容易被忽略:一是计算属性可以依赖其他计算属性: 二是 计算属性不仅可以依赖当前 Vue 实例的数据，还可以依赖其他实例的数据，例如:** 

​	**这里我们创建了两个 Vue 实例 appl 和 app2， 在 app2 的计算属性 reversedText 中，依赖的是 appl 的数据 text，所以当 text变化时，实例 app2 的计算属性也会变化。这样的用法在后面章节介 绍的组件和组件化里会用到，尤其是在多人协同开发时很常用，因为你写的 一个组件所用得到的数 据需要依赖他人的组件提供。随着后面对组件的深入会慢慢意识到这点 ， 现在可以不用太过了解。** 

### 1.3 计算属性缓存

​	**在上一章介绍指令与事件时，你可能发现调用 methods 里的方法也可以与计算属性起到同样的 作用 ，比如本章第一个示例可以用 methods 改写为:** 

```vue
<div id=” app” >
	{{reversedText()}}
</div>
<script>
var app =new Vue ({
	el :’#app ’,
	data : {
		text :’123,456'
	}
	methods : {
		reversedText : function () {
		//这里的 this 指向的是当前 Vue 实例
			return this.text.split(’,’).reverse().join(’,’);
	}
})
</script>
```

​	**没有使用计算属性，在 methods 里定义了 一个方法实现了相同的效果，甚至该方法还可以接受 参数，使用起来更灵活。既然使用 methods 就可以实现，那么为什么还需要计算属性呢?原因就是 计算属性是基于它的依赖缓存的。 一个计算属性所依赖的数据发生变化时，它才会重新取值，所以 text 只要不改变，计算属性也就不更新，例如:** 

```vue
computed : {
	now : function () { 
		return Date.now(); 
		}
}
```

​	**这里的 Date.now()不是响应式依赖，所以计算属性 now 不会更新。但是 methods 则不同，只要重新渲染 ，它就会被调用，因此函数也会被执行 。**

​	**使用计算属性还是 methods 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。**  

## 二、v-bind及class与style绑定

### 2.1 了解v-bind指令

### 2.2 绑定class的几种方式

### 2.3 绑定内联样式

### 2.4 实战-利用计算属性、指令等知识开发购物车

## 三、自定义指令

### 3.1 自定义指令基本用法

### 3.2 实战-开发一个可从外部关闭的下拉菜单

### 3.3 实战-开发一个实时时间转换指令v-time

```

```



## 四、课后练习

### 4.1 练习一：

> 在当前购物车示例基础上扩展商品列表 ，新增一项是否选中该商品的功能，总价变为只计算 选中商品的总价 ， 同时提供一个全选的按钮。 

### 4.2 练习二：

> 将商品列表 list 改为一个二维数组来实现商品的分类 ，比如可分为“电子产品”“生 活用品”和“果蔬”， 同类商品聚合在一起。提示，你可能会用到两次v-for。 

### 4.3 练习三：

> 开发一个自定义指令 v-birthday，接收一个出生日期的时间戳，将它转换为己经出生 了 xxx 天 

### 4.4 练习四：

> 扩展练习 1 的 自定义指令 v-birthday，将出生了 xxx 天转换为具体年龄，比如 25 岁 8个月 10天。 



